
package pwd;

use vars qw($port %pwd %instanceAuth %users %encryption );

$port=1579;

%pwd = (

	sherlock => {

		ts01 => {
			system	=> 'hoser', 
			sys		=> 'hosehead'
		}

	},

	watson => {

		ts99 => {
			system	=> 'wazzup', 
			sys		=> 'wizard'
		},

		ts98 => {
			system	=> 'whyn0t',
			sys		=> 'bcuz'
		}
	}

);

%instanceAuth = (

	sherlock => {

		ts01 => {
			system	=> [ qw(andyd jkstill) ],
			sys		=> [qw(andyd)]
		}

	},

	watson => {

		ts99 => {
			sys	=> [qw( scott andyd )]
		}
	}
	
);

%users = (
	andyd => 'perlgeek',
	jkstill => 'getal1fe',
	scott => 'tiger'
);

%encryption = (
	# level options are 'simple' and 'advanced'
	# advanced is not yet implemented
	level => 'simple',

	# make your key as long as you like, but it will be truncated
	# to 56 bytes 
	key => 'One Ring to bring them all and in the darkness bind them',

	# don't change this
	maxKeyLen => 56
);

1;


__END__

# password server authentication file

=head1 pwd.conf

Password Server Authentication Configuration

=cut

=head1 Usage

This is designed to be used via the  ConfigLoad.pm module.

If this file is located in your $HOME directory, just
load it like this:

  use PDBA::ConfigFile;
  unless ( new PDBA::ConfigLoad( FILE => 'pwd.conf', PATH => $HOME ) ) {
    die "unable to load pwd.conf\n";
  }

  The PATH argument was not actually necessary, as ConfigFile will search
  your home directory by default.

=cut

=head1 Configuring

The easiest part of the configuration is setting the port.  The password
server needs to open a TCP socket, and requires a port to listen on.

This is a simple edit; simply set the port number.  The default above
is 1579.

e.g. $port = 1579;

The format of the rest of the file may appear daunting, but don't let 
it fool you, it's really quite simple.

The first data structure is %pwd.  This could be referred to as a hash 
of hashes of hashes.  It's really not too difficult once you get used 
to it.

It is used to specify the passwords for each account that you wish to
be available via the password server.  The passwords are specified by
server, instance and account.


How can you tell if your configuration file will parse without actually 
running the program it's used for?  Here's how:

  perl -c pwd.conf

If there are any errors, they will appear.  The '-c' flag tells Perl
to just compile the code without executing it. It actually does a little
more than that, but those details are out of scope for this.

Here's a handy template to use. 

 %pwd = (

    system_name_1 => {

       database_1 => {
          username_1 => 'password', 
          username_2 => 'password'
       }

    },

    system_name_2 => {

       database_1 => {
          username_1 => 'password', 
          username_2 => 'password'
       },

       database_2 => {
          username_1 => 'password',
          username_2 => 'password'
       }
    }

 );


=cut

=head1 Accessing the elements

This is a little tricky.  Here's a series of loops that will extract
all servers, instances, usernames and passwords from the configuration
file.  

 use PDBA::ConfigFile;

 unless ( new PDBA::ConfigLoad( FILE => 'pwd.conf', PATH => './' ) ) {
    die "could not load pwd.conf\n";
 }

 $t=0;
 for my $server ( keys %pwd::pwd ) {
    print "\t" x $t, "server: $server\n";
    $t++;
    for my $instance ( keys %{$pwd::pwd{$server}} ) {
       print "\t" x $t, "instance: $instance\n";
       $t++;
       for my $user ( keys %{$pwd::pwd{$server}->{$instance}} ) {
          print "\t" x $t, "username: $user",
             "password: $pwd::pwd{$server}->{$instance}{$user}\n";
       }
       $t--;
    }
    $t--;
 }

To get an accounts password for a database on a particular server, this
the line of code that retrieves it:

            my $password = $pwd::pwd{$server}->{$instance}{$user};

See, that's not so bad.  If you can deal with TNS Names files, this will
be a piece of cake!

Keep in mind that the name of the hash must remain '%pwd'

An optional feature is found in the %instanceAuth hash.  This can be 
used to limit which users are able to retrieve a password for a 
particular account.

If this structure is not used, all users found in %users hash will 
be able to access all passwords for all accounts.

If you have one or two accounts that you want to limit access to, you
can do so with %instanceAuth.  Any accounts not specified will be 
available to all authorized users.

Consider this example.  It is based on the servers found in the %pwd 
example. Int %pwd, there are 2 servers with 3 Oracle instances, and 
there are two accounts in each instance ( sys and system ) that you
are serving passwords for.  This is a total of six passwords.

Let's say that you want to allow andyd and jkstill to have access to
the system account on ts01, only andy has access to the sys account
on ts01, and scott and andyd are to have access to the sys account
on ts99.

All authorized users of the password server ( as found in %users hash )
are to have access to the the supplied accounts ( sys and system ) in
the ts98 instance, as well as the system account in ts99.

The following entries in %instanceAuth will accomplish this. The only 
entries need are for accounts for which you wish to limit the users
that can retrieve the passwords.

 %instanceAuth = (

    sherlock => {

       ts01 => {
          system	=> [ qw(andyd jkstill) ],
          sys		=> [qw(andyd)]
       }

    },

    watson => {

       ts99 => {
          sys	=> [qw( scott andyd )]
       }
    }
	
 );


Notice that this structure is similar to the %pwd structure, but is 
not identical.  The lowest level entry in the %pwd structure is a hash
value, while the lowest level entry in the %instanceAuth structure is
something called an 'anonymous array'.  

It's called an anononymous array because the data is in square brackets 
[] indicating an array, but there is no name associated with it.

The quote word operator ( qw ) is simply a handy way to quote several 
words without actually using quotes. This is very useful when you have
a number of entries to make.

You can use quotes instead if you like.

For example:  account_1 => [ qw(andyd jkstill) ],

becomes: account_1 => [ 'andyd', 'jkstill' ],

Again, if you can handle tnsnames.ora, you'll have no trouble with this.

Here's a handy template for building the %instanceAuth hash.

 %instanceAuth = (

    server_1 => {

       instance_1 => {
          account_1 => [ qw(andyd jkstill) ],
          account_2 => [qw(andyd)]
       },

       instance_2 => {
          account_1 => [ qw(andyd jkstill) ],
          account_1 => [qw(andyd)]
       },

    },

    server_2 => {

       instance_1 => {
          account_1  => [qw( scott andyd )]
       }
    }
	
 );

Data sent across the network ( i.e. your users passwords ) will
be encrypted.  There are two levels of encryption, simple and 
advanced.

Simple encryption requires a key phrase that will be used encrypt
the authentication information as it traverses the network. This
same key phrase must be used at both ends of the connection. It
is stored in the pwd.conf file at the server end.  The client end
will make use of the configuration file gwp.conf to store the key
phrase.

This eliminates the need to use the passphrase on the command line,
and enables you to set file security levels that will keep its 
contents from prying eyes.

The configuration data for encryption is stored in the %encryption
hash. There are only three elements, and all are required. Please
don't change the value for maxKeyLen, as that could cause your
encryption to fail.

Here's an example of the %encryption hash:

  %encryption = (

	  # level options are 'simple' and 'advanced'
	  # advanced is not yet implemented
	  level => 'simple',

	  # make your key as long as you like, but it will be truncated
	  # to 56 bytes 
	  key => 'One Ring to bring them all and in the darkness bind them',

	  
	  # don't change this!
	  maxKeyLen => 56
  );

As for the advanced encryption, well, that's not yet implemented.  It
will feature the use of public/private keys to elimiate the use of the
pass phrase, and provide tighter security.


=cut


